"""
Program Name: cup_handle_detect
Author: Brian Anderson
Origin Date: 18Mar2025
Version: 1.6

    Pattern Detection Logic Library--Cup and Handle; Normal (double hump), and Saucer-Rounded Bottom Variant
    This file contains functions for identifying common stock price patterns
    Identifies the 'Cup and Handle' pattern, including saucer/rounded bottom variations.
    :param price_series: List of prices over time
    :param volume_series: Corresponding list of volumes
    :return: Boolean indicating whether the pattern was found

    This file will be referenced as a library program to be recalled within a main trading program.
"""
import numpy as np
#import matplotlib.pyplot as plt
from scipy.stats import linregress

def detect_cup_and_handle(price_series, volume_series, visualize=False):
    # Insert filtering code here to remove extreme outliers or erroneous data points,
    #   or insert code here to handle erroneous open/close values from data sources, if we have not already accounted for this.
    # Insert code here to pull averaged stock price chunks from another library program if needed (probably Stock_Stats)
    # Insert check here to see if machine learning has been enabled in the main program. (further development needed)
    # If ML is to be used, matrices and coefficients, et cetera, wil need to be added here.
    
    # Step 1: Apply a rolling median filter to smooth out price anomalies
    window_size = 3  # Adjust window size as needed; use 2 if this smoothes too much data.
    smoothed_prices = np.convolve(price_series, np.ones(window_size)/window_size, mode='valid')
    
    # Step 2: Identify the bottom of the cup (rounded bottom check)
    min_index = np.argmin(smoothed_prices);
    left_side = smoothed_prices[:min_index]; right_side = smoothed_prices[min_index:];
    
    # Step 3: Ensure left and right sides form a U or rounded saucer shape
    if len(left_side) == 0 or len(right_side) == 0:
        return False  # Not enough data for a pattern
    
    # Quadratic Fit to Ensure Concavity (U-Shape Detection)
    x_quadFit = np.arange(len(smoothed_prices)); y_quadFit = np.array(smoothed_prices);
    
    # Fit a quadratic curve (ax^2 + bx + c)
    coeffs = np.polyfit(x_quadFit, y_quadFit, 2)  # Get quadratic coefficients a, b, c; Note: why use 2???
    a_coeff_quadFit, b_coeff_quadFit, c_coeff_quadFit = coeffs;  # Extract values; should that mean 'apply'???
    
    if a_coeff_quadFit >= 0:  # Ensuring concave-up shape
        return False  # Not a valid cup shape
    
    """
    Leave this code for later 'shallow pool' evaluation consideration.
    # Handling the "shallow pool" effect by ensuring a slight flattening on the right side
    right_fit = np.polyfit(np.arange(len(right_side)), right_side, 2)
    a_right, _, _ = right_fit
    if abs(a_right) < abs(a) * 0.7:  # Right side is flatter than the whole cup
        return False  # Too shallow, invalid cup formation
    """
  
    # Step 4: Identify the handle (slight pullback after U formation)
    handle_start = min_index + int(len(right_side) * 0.5)
    handle = smoothed_prices[handle_start:]
    
    if len(handle) < 2: return False  # Handle must exist; but what if we are not sure, but the handle is resolving???
    
    # Ensure handle is a minor pullback, not a deep drop
    cup_high = max(left_side.tolist() + right_side.tolist())
    min_price = smoothed_prices[min_index]
    handle_depth = max(handle) - min(handle)
    
    # Softening: Allow a tolerance margin in handle depth threshold (instead of strict 0.2 limit)
    max_allowed_depth = 0.2 * (cup_high - min_price) * 1.1  # 10% buffer added
    if handle_depth > max_allowed_depth: return False  # Handle is too deep
    
    # Ensure handle is of reasonable length
    cup_width = len(left_side) + len(right_side);
    
    # Softening: Allow a small buffer on the max handle width limit (0.6 * cup_width)
    max_handle_width = 0.6 * cup_width * 1.05  # 5% flexibility added
    if not (0.1 * len(smoothed_prices) < len(handle) < max_handle_width):
        return False  # Handle is too short or too long
    
    # Ensure handle slope is slightly downward or neutral
    handle_x = np.arange(len(handle)) #what is arange vs arrange???
    slope, _, _, _, _ = linregress(handle_x, handle) #this is getting too fancy here; might be problematic
    
    # Softening: Instead of rejecting all positive slopes, allow slight upward movement (margin of 0.01)
    if slope > 0.1:  #originally as 0.01
        return False  # Handle should be slightly downward or neutral
    
    # Step 5: Volume Confirmation
    cup_volume = np.mean(volume_series[:min_index])
    handle_volume = np.mean(volume_series[handle_start:])
    breakout_volume = volume_series[-1]  # Most recent volume
    
    # Softening: Instead of requiring exactly 1.5x volume increase, allow a gradual threshold
    min_required_breakout_volume = 1.4 * handle_volume  # Reduced from 1.5x strict requirement
    if breakout_volume < min_required_breakout_volume:  return False  # Breakout should have strong volume
    
    # Step 6: Ignore breakout spikes lasting â‰¤2 candles unless confirmed by volume
    breakout_spike_duration = np.sum(smoothed_prices[-3:] > cup_high)  # Last 3 candles
    
    # Softening: Instead of hard rejecting all short-lived spikes, apply volume check
    if breakout_spike_duration <= 2 and breakout_volume < 1.9 * handle_volume:  # More flexible threshold
        return False  # False breakout, ignore
    
    # Visualization
    if visualize:
        plt.figure(figsize=(10,5))
        plt.plot(price_series, label='Stock Price', color='blue')
        plt.scatter(min_index, smoothed_prices[min_index], color='red', marker='o', label='Cup Bottom')
        plt.axvspan(handle_start, handle_start + len(handle), color='orange', alpha=0.3, label='Handle Region')
        plt.arrow(len(price_series)-1, cup_high, 0, 0.05 * cup_high, head_width=3, head_length=0.03 * cup_high, color='green', label='Breakout Zone')
        plt.legend()
        plt.title("Cup and Handle Pattern Detection")
        plt.xlabel("Time")
        plt.ylabel("Price")
        plt.show()
    
    return True  # Cup and handle detected
